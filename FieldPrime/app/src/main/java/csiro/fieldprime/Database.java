/*
 * Database.java
 * Michael Kirk 2013
 * 
 * Class for accessing the database. 
 */

package csiro.fieldprime;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Locale;

import android.content.ContentValues;
import android.content.Context;
import android.content.res.AssetManager;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import static csiro.fieldprime.DbNames.*;

public class Database extends SQLiteOpenHelper {

	// CONSTANTS: =====================================================================================================
	/*
	 * DATABASE_VERSION
	 * This must be incremented when the database structure changes - see onUpgrade()
	 * Version history:
	 * ...
	 * 10 Added traitString table.
	 * 11 Added local field to node table.
	 *    Added system table.
	 * 12 Added flags to trait table.
	 */	
	private static final int DATABASE_VERSION = 12;

	
	// DATA-INSTANCE: ====================================================================================================
	private SQLiteDatabase mDB = null;
	private Context mCtx;
	private String mDbFilename;
	

	// METHODS: ======================================================================================================

	public Database(Context ctx, String dbFile) {
		super(ctx, dbFile, null, DATABASE_VERSION);
		mCtx = ctx;
		mDbFilename = dbFile;
		mDB = getWritableDatabase();
	}

	public SQLiteDatabase getDatabase() {
		return mDB;
	}
	public boolean copyDatabase(String copyFilename) {
		close();
		boolean res = Util.copyFile(mDbFilename, copyFilename);
		mDB = getWritableDatabase();
//		Globals.g.db = mDB;
		return res;
	}
	
	/*
	 * GenerateNewID()
	 * For a couple of tables, we have the problem of needing unique ids, which can sometimes be provided from the server,
	 * and sometimes not (eg when loading trials from csv files). When the id is NOT provided by the server, we need to
	 * generate a unique id that does not equal any current or potential future server id. We solve this problem by
	 * using negative values (under the assumption that all server ids will be positive), and generate one lower than any already
	 * in the table.
	 * NB, since a value is generated by considering the negative values already in the table, it is crucial that the returned
	 * id be saved to the relevant table before any other ids are generated for the table.
	 * NB2: Might be better to make local ids start above some range (eg 24million), since it seems negative numbers are
	 * inefficiently supported in sqlite. 
	 */
	public static final long MIN_LOCAL_ID = 24000000;

	public long GenerateNewID(String tableName, String idFieldName) {
		Cursor ccr = null;
		try {
			ccr = mDB.rawQuery(String.format("select max(%s) from %s", idFieldName, tableName), null);
			if (ccr.moveToFirst()) {
				long currMax = ccr.getLong(0);
				if (currMax < MIN_LOCAL_ID)
					return MIN_LOCAL_ID;
				else
					return currMax + 1;
			} else
				return MIN_LOCAL_ID;
		} finally { if (ccr != null) ccr.close(); }
	}

	@Override
	public void onCreate(SQLiteDatabase db) {
		// Read the sql creation commands from bundled asset file, and run them:
		try {
			AssetManager assets = mCtx.getAssets();
			InputStream stream = null;
			stream = assets.open("setup.sql");
			InputStreamReader isr = new InputStreamReader(stream);
			BufferedReader br = new BufferedReader(isr);
			String line;
			while ((line = br.readLine()) != null) {
				if (line.matches("create.*")) {
					while (!line.matches(".*;.*")) { // There may be more lines
						line += br.readLine();
					}
					db.execSQL(line);
				}
			}
		} catch (java.lang.Throwable e) {
			Util.msg("exception in onCreate: " + e.getMessage());
			e.printStackTrace();
		}
	}

	/*
	 * onUpgrade()
	 * This is triggered when the DATABASE_VERSION defined above has changed since the database was last used.
	 * Consequently DATABASE_VERSION should be incremented when there has been some structural database changes,
	 * eg changes to tables or fields.
	 * If the database structure has changed yet we still use an old database, crashes are likely to occur
	 * (because the code will reflect the new structure, which the database doesn't match).
	 * MFK:
	 * At the moment we simply warn the user (better than just letting them work away until they crash).
	 * We could instead clear the database and rebuild with new structure. Or possible use a version numbering
	 * system such that we could determined whether it was safe to continue to use the old database
	 */
	@Override
	public void onUpgrade(SQLiteDatabase db, int oldVer, int newVer) {
		Util.msg("Warning - database structure has changed. You may need to delete your database");
		// MFK - should check with user before deleting all data?	
		
		// Code to delete every table in the database, and then recreate (untested).
//		Cursor c = db.rawQuery("SELECT name FROM sqlite_master WHERE type='table'", null);
//		if (c.moveToFirst()) {
//			String tableName = c.getString(0);
//			do {
//				db.execSQL("DROP TABLE IF EXISTS " + tableName); 
//			} while (c.moveToNext());
//		}
//		onCreate(db);
	}
	
	@Override
	public void onOpen(SQLiteDatabase db) {
		super.onOpen(db);
		if (!db.isReadOnly()) {
			// Enable foreign key constraints, I've haven't tested to see if this is necessary, but it's doing no harm.
			db.execSQL("PRAGMA foreign_keys=ON;");
		}
	}
}
